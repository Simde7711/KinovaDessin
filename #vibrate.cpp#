#include "./include/SessionManager.h"
#include "./include/DeviceConfigClientRpc.h"
#include "./include/BaseClientRpc.h"
#include "./include/TransportClientUdp.h"
#include "./include/BaseClientRpc.h"
#include "./include/RouterClient.h"
#include <cstdio>

namespace k_api = Kinova::Api;

#define PORT 10000

#define PORT_REAL_TIME 10001

k_api::Base::BaseClient *base;

k_api::DeviceConfig::DeviceConfigClient *device_config;

k_api::SessionManager *session_manager;

k_api::RouterClient *router;

k_api::TransportClientUdp *transport;

void example_api_creation(int argc, char **argv) {

  if (argc != 3) {printf("usage: \n vibrate_kinova [IP_ADRESS] [username] [password]");}
    // -----------------------------------------------------------
    // How to create an API with the SessionManager, DeviceConfigClient and BaseClient services
    auto error_callback = [](k_api::KError err){ cout << "_________ callback error _________" << err.toString(); };
    transport = new k_api::TransportClientUdp();
    router = new k_api::RouterClient(transport, error_callback);
    printf(argv[1]);
    transport->connect(argv[1], PORT);

    // Set session data connection information
    auto create_session_info = k_api::Session::CreateSessionInfo();
    printf(argv[2]);
    create_session_info.set_username(argv[2]);
    printf(argv[3]);
    create_session_info.set_password(argv[3]);
    create_session_info.set_session_inactivity_timeout(60000);   // (milliseconds)
    create_session_info.set_connection_inactivity_timeout(2000); // (milliseconds)

    // Session manager service wrapper
    std::cout << "Creating session for communication" << std::endl;
    session_manager = new k_api::SessionManager(router);
    session_manager->CreateSession(create_session_info);
    std::cout << "Session created" << std::endl;

    // Create DeviceConfigClient and BaseClient
    device_config = new k_api::DeviceConfig::DeviceConfigClient(router);
    base = new k_api::Base::BaseClient(router);

}

void prepare(k_api::Base::BaseClient* base)
{
	auto servomode = k_api::Base::ServoingModeInformation();
	servomode.set_servoing_mode(k_api::Base::ServoingMode::);
	base->SetServoingMode(servomode);
	std::this_thread::sleep_for(std::chrono::milliseconds(500));
}

bool angular_move()
{
	auto movement = k_api::Base::Action();
}

k_api::SessionManager vibrate(k_api::Base::BaseClient* base, int MS) {
  
}

void destroy_API(k_api::SessionManager* sessionman)
{

    // Close API session
    sessionman->CloseSession();

    // Deactivate the router and cleanly disconnect from the transport object
    router->SetActivationStatus(false);
    transport->disconnect();

    // Destroy the API
    delete base;
    delete device_config;
    delete session_manager;
    delete router;
    delete transport;
}

int main(int argc, char **argv)
{
  destroy_API(vibrate(example_api_creation(argc, argv),4000));
}
